---
title: 6. Databases
layout: post
date: 21/12/15
---

### Database

- can handle large amount of data efficiently
- provide tools to insert, query and update data
- they offer security features
- they can scale well
- SQL: Structured Query Language, relational databases. Use tables. MySQL, Postgres, SQLite
- NoSQL: store information in xml, yaml, json. No tables or schema to follow. MongoDB, Redis, Neo4j

### MongoDB

- mongo is commonly used with node and express
- easy to start and poular
- [installation](https://zarkom.net/blogs/how-to-install-mongodb-for-development-in-windows-3328)
- multiple databases at the same time
- create a new db `use dbName` (won't appear until there is data in it)
- BSON binary json, more compact in memory

### MongoDB CRUD operations
[Resource](https://docs.mongodb.com/manual/crud/)

#### Create

- insert data in collections `db.dogs.insertOne({name: "Charlie", age:3, breed:"corgie", isFriendly: true})`
- `db.dogs.insert([{name: "Walt", breed: "Golden", age: 14}, {name: "Tonya", breed:"Chihua", age:17}])`
- `show collections`
- `db.dogs.find()`

#### Find

- `db.dogs.find({breed: "corgi"})`

#### Updating

- `db.dogs.updateOne({name: "Charlie"}, {$set: {age: 15}})`

#### Deleting

- `db.dogs.deleteOne({name: "Charlie"})`
- `db.dogs.deleteMany({})`

#### Additional operators

- for nested properties: `db.dogs.find({'personality.childFriendly': true})`
- for multiple properties: `db.dogs.find({'personality.childFriendly': true, age: 10})`
- comparison, logical operators [etc](https://docs.mongodb.com/manual/reference/operator/query/) `db.dogs.find({ age: {$gt:20} })`
- in operator: the value of a field equals any value in the specified array `db.dogs.find({breed: {$in ['Mutt', 'Corgi']}})`
- or `db.dogs.find({$or: [{'personality.catfirendly': true}, {age: {$lte:2}}]})`

### Mongoose
[Resource](https://mongoosejs.com/)
- Connect node to MongoDB -> driver or Mongoose
- ODM: Object Data Mapper. Maps data from Mongo to JS objects
- ORM: same but for SQL data

Create a new folder and initialize npm 
`npm init -y`
Install mongoose 
`npm i mongoose`
Make an index.js 
`touch index.js`
Require mongoose
```js
const mongoose = require('mongoose');

main().catch(err => console.log(err));

async function main() {
  await mongoose.connect('mongodb://localhost:17017/movieApp');//movieApp is the database
  console.log('connection open!')
} 
```

Make a model (class) to interact with the database. 
1. Define a schema
```js
const productSchema = new mongoose.Schema({
    name: String,
    price: Number,
    quantity: Number
})
```
2. make a model from the schema
```js
const Product = mongoose.model('Product', productSchema) //Product should be uppercase and singular. mongoose will create a collection called movies
```
3. Create an instance of Movie
```js
const amad = new Product({name: "Amad", price: 1986});
```
4. Run node, load index.js from the project folder
```js
node
.load index.js
```
5. save it into mongodb
`amad.save();`

#### insert.Many()
```js
Product.insertMany([
    {name: 'Amel', price:2001, quantity:8.3, rating:'R'},
    {name: 'The Iron', price:2004, quantity:3.3, rating:'R'},
])
.then(data => {
    console.log("it works")
    console.log(data)
})
```
No need to save into the db.

#### Finding
Can be treated as promises but they are not promises
```js
 Product.find({}).then(data => console.log(data))
 Product.findById('123').then(data => console.log(data))
 ```
 #### Updating
`Product.updateOne({name:'Amad'},{price: 1984}).then( res => console.log(res))` //does not return the object
`Product.updateManu({name: {$in['Amd', 'sbyme']}}, {price:10}).then(res => console.log(res))` //does not return the object
`Product.findOneAndUpdate({name: 'tir'},{price: 7.0}).then(m => console.log(m))` //we get back the (old) object
`Product.findOneAndUpdate({name: 'tir'},{price: 7.0},{new: true}).then(m => console.log(m))` //we get back the (new) object

#### Deleting
`Product.remove({name: 'Amel'}).then(msg => console.log(msg))`
`Product.deleteMany({price: {$gte: 1999}}).then(msg => console.log(msg))`
`Product.findOneAndDelete(...)` \\return the deleted object

#### Schemas
```js
const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
        maxlength: 10
    },
    price: {
        type: Number,
        required: true,
        min: 0
    },
    onSale: {
        type: Boolean,
        default: false
    },
    qty: {
        online: {
            type: Number,
            default: 0
        },
        inStore: {
            type: Number,
            default: 0
        }
    }
})
```
Validation applies when data is created. When updating, it has to be set:
`Product.findOneAndUpdate({name: 'Tyre'}, {price: 10},{new: true, runValidators: true})`

#### Validation Errors
```js
    price: {
        type: Number,
        required: true,
        min: [0, "Price must be positive"]
    },
    size:{
        type: String,
        enum: ['S','M','L'] //only these strings are allowed
    }
```

#### Model Instance
do not use arrow function
```js
productSchema.methods.toggleOnSale = function() {
    this.onSale = !this.onSale;
    return this.save();
}

productSChema.methods.addCategory = function(newCat){
    this.categories.push(newCat);
    return this.save();
}

const findProduct = async () => {
    const foundProduct = await Product.findOne({name: 'whatever'});
    await foundProduct.toggleOnSale();
    await foundProduct.addCategory('Outdoors');
}
```
#### Static Methods
```js
productSchema.statics.fireSale = function(){
    return this.updateMany({},{onSale: true, price: 0})//return allows await
}
Product.fireSale().then(res => console.log(res))
```
#### Virtuals
[Resource](https://mongoosejs.com/docs/tutorials/virtuals.html)
Add properties to schema that do not exist in the database but we can derive. i.e. full name in a database
```js
const personSchema = new mongoose.Schema({
    first: String,
    last: String
})

personSchema.virtual('fullName').get(function () {
    return `${this.first} ${this.last}`
})
  set(function(v) {
    const firstName = v.substring(0, v.indexOf(' '));
    const lastName = v.substring(v.indexOf(' ') + 1);
    this.set({ firstName, lastName });
  });
```
#### Middleware
If youre move a user you can remove all his comments and activity:
`.pre`
`.post`
```js
presonSchema.pre('save', async function(){
  this.first = 'Yo';
  this.last = 'Meme';  
})

presonSchema.post('save', async function(){
    ...
})
```

### Mongoose + Express
1. Empty app
`npm init -y`
2. install express, ejs and mongoos
3. create folder *views* and *index.js*
4. add *express* and *mongoose*

```js
const express = require ('express')
const app = express()
const path = require('path')
const mongoose = require('mongoose');

main().catch(err => console.log(err));

async function main() {
  await mongoose.connect('mongodb://localhost:27017/shopApp'); //create a db named test
  console.log('connection open')
}

app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.listen(3000, () =>{
    console.log('app is listening on port 3000')
})

app.get('/dog', (req, res)=>{
    res.send('woof')
})
```
5. create folder *models* and *product.js*

```js
const mongoose = require('mongoose')

const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    price: {
        type: Number,
        required: true,
        min: 0
    },
    category: {
        type: String,
        enum: ['fruit','vegetable', 'dairy']
    }
})

const Product = mongoose.model('Product', productSchema) //creates a collection named movies

module.exports = Product;
```

6. create some dummy data in *seed.js*

```js
const mongoose = require('mongoose');
const Product = require('./models/product');

main().catch(err => console.log(err));

async function main() {
  await mongoose.connect('mongodb://localhost:27017/farmStand'); //create a db named test
  console.log('connection open')
}

const seedProducts = [
{   name: 'eggplan',
    price: 1.00,
    category: 'vegetable'
},
{   name: 'melon',
    price: 4.99,
    category: 'fruit'
},
{   name: 'watermelon',
    price: 4.99,
    category: 'fruit'
},
{   name: 'celery',
    price: 3.99,
    category: 'vegetable'
},
{   name: 'chocolate milk',
    price: 1.50,
    category: 'dairy'
},
{   name: 'cheese',
    price: 7.99,
    category: 'dairy'
}
]

Product.insertMany(seedProducts)
.then(res => console.log(res))
.catch(e => console.log(e))
```
7. run `node seed.js` to save the data in the database
8. check the data has been saved
`show dbs`
`use farmStand`
`show collections`
`db.products.find()`
9. setup a route to display the products

```js
app.get('/products', async (req, res)=>{
    const products = await Product.find({})
    //res.send('all products will be here')
    res.render('products/index', {products})
})
```

10. create a folder *products* in views and *index.ejs* 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>All Products</h1>
    <ul>
        <% for (let product of products){%>
            <li> <%= product.name %> </li>
        <% } %>
    </ul>
</body>
</html>
```

11. setup a show route using find by id

```js
app.get('/products/:id', async (req, res) => {
  const {id} = req.params;
  const product = await Product.findById(id);
  //res.send('details page')
  //console.log(product);
  res.render('products/show', {product})
})
```

12. *show.ejs*

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= product.name %></title>
</head>
<body>
    <h1><%= product.name %></h1>
    <ul>
        <li>Price: <%= product.price %></li>
        <li>Category: <%= product.category %></li>
    </ul>
</body>
</html>
```

13. add links in the index page

```html
    <ul>
        <% for (let product of products){%>
            <li> <a href="/products/<%= product._id %>"><%= product.name %></a> </li> 
        <% } %>
    </ul>
```

14. add new form

```html
    <h1>Add Product</h1>
    <form action="/products" method="POST">
        <label for="name">Product Name</label>
        <input type="text" name="name" id="name" placeholder="product name">
        <label for="price">Price</label>
        <input type="number" name="price" id="price" placeholder="product price">
        <label for="category">Category</label>
        <select name="category" id="category">
            <option value="fruit">fruit</option>
            <option value="vegetable">vegetable</option>
            <option value="dairy">dairy</option>
        </select>
        <button>Submit</button>
    </form>
```

```js
//parse response
app.use(express.urlencoded({extended: true}))

app.get('/products/new', (req, res) => {
  res.render('products/new')
})

app.post('/products', async (req, res) =>{
  const newProduct = new Product(req.body)
  await newProduct.save();
  console.log(newProduct);
  res.redirect(`/products/${newProduct._id}`);
})
```

15. Updating products - install method-override

```js
const methodOverride = require ('method-override')
app.use(methodOverride('_method'));
```

```html
    <form action="/products/<%= product._id%>?_method=PUT" method="POST">
```

```js
app.get('/products/:id/edit', async (req, res)=>{
  const {id} = req.params;
  const product = await Product.findById(id)
  res.render('prodcuts/edit', {product})
})
```

16. update data in mongoose db

```js
app.put('/products/:id', async (req, res)=>{
  const {id} = req.params;
  const product = await Product.findByIdAndUpdate(id, req.body, {runValidators: true, new: true});
  res.redirect(`/products/${product._id}`);
})
```

```html
    <a href="/products/<%= product._id %>/edit">Edit</a>
```

17. Fix category selector in *edit.js* page

```html
   <option value="fruit" 
   <%=product.category === 'fruit' ? 'selected' : ''%>
   >fruit</option>
```